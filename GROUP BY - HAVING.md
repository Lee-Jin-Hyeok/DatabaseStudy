## GROUP BY - HAVING

GROUP BY절은 어떤 컬럼을 하나의 그룹으로 묶는다.
이렇게 하나의 그룹으로 묶게 되면 같은 컬럼으로 된, 즉 중복을 제거할 수 있기 때문에 많이 사용된다.
만약 다음과 같은 테이블이 있다고 하자.

| name   | id   | age  |
| ------ | ---- | ---- |
| 이진혁 | 1    | 18   |
| 손정우 | 2    | 18   |
| 유시온 | 3    | 19   |
| 김대웅 | 4    | 20   |

위 테이블이 존재할 때, age 컬럼을 기준으로 GROUP BY를 하면 어떻게 될까?

```java
SELECT * FROM student GROUP BY age;
```

그러면 다음과 같이 값이 나온다.

| name   | id   | age  |
| ------ | ---- | ---- |
| 이진혁 | 1    | 18   |
| 유시온 | 3    | 19   |
| 김대웅 | 4    | 20   |

이렇게 age가 18로 같은 이진혁과 손정우 컬럼이 합쳐진 것을 알 수 있다.
근데 이럴 때 name과 id는 어떻게 합쳐졌는지를 보면
이진혁으로 통합되고 손정우 컬럼은 사라졌다싶이 된다.
이것은 사실 합쳐졌는데 표기할 것이 마땅치 않아서 가장 위의 컬럼이 표시되는 것이다.

그럼 HAVING절은 무엇일까?
기존의 FROM절의 결과에 조건을 달기 위해서는 WHERE절을 사용했었다.
HAVING은 GROUP BY절의 결과에 대하여 조건을 거는 것이다.
따라서 SELECT문은 다음과 같은 문법으로 사용된다.

```slq
SELECT [SELECT 표현식] FROM [테이블's] WHERE [조건] GROUP BY [그룹 표현식] HAVING [조건]
```

이렇게 WHERE절에서 조건을 검사하고 GROUP BY를 한 뒤 또 조건을 검사하는 형식으로 표현된다.
그리고 이 SELECT문이 모두 완성된 것이 아니라 뒤에 ORDER BY와 LIMIT과 같은 형식도 붙을 수 있다.

그래서 만약 위의 테이블에서 id가 4보다 작은 컬럼들만 그룹핑할 경우에는 다음과 같이
HAVING절을 작성할 수도 있다.

```sql
SELECT * FROM student GROUP BY age HAVING id < 4;
```

이러면 id가 4이상인 김대웅 컬럼은 그룹에서 삭제된 다음과 같은 형태로 보여지게 된다.

| name   | id   | age  |
| ------ | ---- | ---- |
| 이진혁 | 1    | 18   |
| 유시온 | 3    | 19   |